<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Annulus Particle Dynamics Explorable</title>

  <!-- KaTeX (for LaTeX rendering) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"
    onload="renderMathInElement(document.body);
"></script>

  <style>
    :root {
      --border:#d1d5db;
 --text:#111827;
 --muted:#6b7280;
 --bg:#ffffff;
 --card:#ffffff;
 --chip:#ffffff;

      --blue:#2563eb;
 --blue-soft:rgba(59,130,246,0.25);
 --stroke:#1f2937;

      --particle:#f50b0b;
 /* amber */ --particle-edge:#000000;
 /* darker amber-brown */
      --link:#0ea5e9;
 /* cyan-ish links */
    }
    * { box-sizing: border-box;
 }
    body { margin:0;
 font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
 color:var(--text);
 background:var(--bg);
 }
    .container { display:grid;
 grid-template-columns: 1fr 2fr;
 gap:1rem;
 padding:1rem;
 }
    @media (max-width: 900px) { .container{ grid-template-columns: 1fr;
 } }
    .card { background:var(--card);
 border:1px solid var(--border);
 border-radius:1rem;
 padding:1rem;
 box-shadow:0 4px 10px rgba(0,0,0,0.05);
 }
    .card h3 { margin:0 0 .5rem 0;
 }
    .slider-label { display:flex;
 justify-content:space-between;
 gap:1rem;
 font-size:.9rem;
 margin:.4rem 0 .2rem;
 }
    .val { color:var(--muted);
 font-variant-numeric: tabular-nums;
 }
    .slider { width:100%;
 }
    .row { display:flex;
 gap:.5rem;
 align-items:center;
 flex-wrap:wrap;
 }
    button { background:#e5e7eb;
 border:1px solid var(--border);
 border-radius:1rem;
 padding:.45rem .9rem;
 cursor:pointer;
 }
    button:hover { background:#d1d5db;
 }
    .switch { display:inline-flex;
 align-items:center;
 gap:.5rem;
 }
    canvas { width:100%;
 height:80vh;
 background:#fff;
 border:1px solid var(--border);
 border-radius:1rem;
 display:block;
 }
    .equations { font-size: 1rem;
 line-height: 1.6;
 color:var(--text);
 }
    .chip { margin-top:.5rem;
 color:#ffffff;
 background:var(--chip);
 display:inline-block;
 border-radius:999px;
 padding:.2rem .6rem;
 font-size:.8rem;
 }
  </style>
</head>
<body>
  <div class="container">
    <div>
      <div class="card">
        <h3>Dynamics &amp;
 Domain</h3>

        <div class="slider-label"><span>N (particles)</span><span id="valN" class="val"></span></div>
        <input type="range" id="N" class="slider" min="10" max="50" step="1" value="20"/>

        <div class="slider-label"><span>Δt</span><span id="valDt" class="val"></span></div>
        <input type="range" id="dt" class="slider" min="0.001" max="0.01" step="0.001" value="0.001"/>

        <div class="slider-label"><span>R<sub>in</sub></span><span id="valRin" class="val"></span></div>
        <input type="range" id="Rin" class="slider" min="0.05" max="0.95" step="0.01" value="0.35"/>

        <!-- R_out fixed (1.00) -->

        <div class="slider-label"><span>Particle Radius</span><span id="valA" class="val"></span></div>
        <input type="range" id="aPx" class="slider" min="1" max="50" step="1.0" value="15.0"/>

        <div class="row" style="margin-top:.6rem">
          <button id="toggle">Pause</button>
          <button id="reseed">Reseed</button>
          <label class="switch"><input type="checkbox" id="showField"> show $$U(\mathbf x)$$</label>
        </div>
        <div class="chip" id="chip"></div>
      </div>

      <div class="card">
        <h3>Forces &amp;
 Noise</h3>
        <div class="slider-label"><span>γ (friction)</span><span id="valGamma" class="val"></span></div>
        <input type="range" id="gamma" class="slider" min="0" max="5" step="0.01" value="2.0"/>

        <div class="slider-label"><span>v<sub>0</sub> (velocity)</span><span id="valV0" class="val"></span></div>
        <input type="range" id="v0" class="slider" min="0" max="2" step="0.01" value="0.30"/>

        <div class="slider-label"><span>σ (noise)</span><span id="valSigma" class="val"></span></div>
        <input type="range" id="sigma" class="slider" min="0" max="1.5" step="0.01" value="0.05"/>
      </div>

      <div class="card">
        <h3>Potential</h3>
        <div class="slider-label"><span>U<sub>0</sub></span><span id="valU0" class="val"></span></div>
        <input type="range" id="U0" class="slider" min="0" max="8" step="0.01" value="4.0"/>

        <div class="slider-label"><span>s (well width)</span><span id="valS" class="val"></span></div>
        <input type="range" id="s" class="slider" min="0.03" max="0.5" step="0.005" value="0.08"/>

        <div class="slider-label"><span># wells (M)</span><span id="valMw" class="val"></span></div>
        <input type="range" id="Mw" class="slider" min="1" max="24" step="1" value="6"/>

        <div class="row" style="margin-top:.2rem">
          <label><input type="radio" name="wmode" value="ring" checked/> Center ring</label>
          <label><input type="radio" name="wmode" value="random"/> Random</label>
        </div>
      </div>

      <div class="card">
        <h3>Contact Network</h3>
        <div class="slider-label"><span>ρ<sub>obs</sub> (arbitrary units)</span><span id="valObs" class="val"></span></div>
        <input type="range" id="obsR" class="slider" min="0.05" max="1.00" step="0.01" value="0.5"/>

        <div class="slider-label"><span>Link width</span><span id="valLW" class="val"></span></div>
        <input type="range" id="linkW" class="slider" min="0.5" max="20" step="0.2" value="5.0"/>

        <div class="slider-label"><span>Link opacity</span><span id="valLA" class="val"></span></div>
        <input type="range" id="linkA" class="slider" min="0" max="1" step="0.05" value="0.6"/>
      </div>

      <div class="card equations">
        <h3>Equations</h3>
        $$\dot{\mathbf x}=\mathbf v,\qquad
          \dot{\mathbf v}= -\nabla U(\mathbf x) + \gamma (v_0 - v)\,\hat{\mathbf v} + \sigma T\hat{\mathbf v}\,\xi(t)$$
        $$U(\mathbf x)=-U_0\sum_i e^{-\lVert \mathbf x-\mathbf x_i\rVert^2/(2s^2)},\quad
          T=\begin{bmatrix}0&-1\\1&0\end{bmatrix}$$
      </div>
    </div>

    <div>
      <canvas id="canvas"></canvas>
    </div>
  </div>

<script>
(() => {
  // ----- State -----
  const state = {
    N: 20, dt: 0.001, Rin: 0.35, Rout: 1.00, // Rout fixed
    aPx: 15.0,
    gamma: 2.0, v0: 0.30, sigma: 0.05,
    U0: 4.0, s: 0.08, Mw: 6, wmode: 'ring',
    showField: false,
    // observation network
    obsR: 0.5, // world units
    linkW: 5., // px
    linkA: 0.8, // 0..1 opacity
    running: true
  };


  // ----- DOM -----
  const byId = id => document.getElementById(id);

  const canvas = byId('canvas');

  const chip = byId('chip');

  const ctx = canvas.getContext('2d');


  const sliders = {
    N:'N', 
    dt:'dt', 
    Rin:'Rin', 
    aPx:'aPx',
    gamma:'gamma', 
    v0:'v0', 
    sigma:'sigma',
    U0:'U0',
    s:'s', 
    Mw:'Mw',
    obsR:'obsR', 
    linkW:'linkW', 
    linkA:'linkA'
  };

  const labels = {
    N:'valN', 
    dt:'valDt', 
    Rin:'valRin', 
    aPx:'valA',
    gamma:'valGamma', 
    v0:'valV0', 
    sigma:'valSigma',
    U0:'valU0', 
    s:'valS', 
    Mw:'valMw',
    obsR:'valObs', 
    linkW:'valLW', 
    linkA:'valLA'
  };


  function fmt(x) { const n=Number(x);
 return (Math.abs(n)>=1? n.toFixed(2): n.toFixed(3).replace(/0+$/,'').replace(/\.$/,''));
 }
  function syncLabels() { for (const k in labels) byId(labels[k]).textContent = fmt(state[k]);
 byId('toggle').textContent = state.running?'Pause':'Play';
 //chip.textContent = `Euler–Maruyama, Δt = ${fmt(state.dt)}`;
 }

  // Bind sliders
  for (const elId in sliders) {
    const k = sliders[elId];
 const el = byId(elId);
 el.value = state[k];

    el.addEventListener('input', () => {
      state[k] = parseFloat(el.value);

      if (k==='Rin') { enforceRadiiConstraints();
 placeWells();
 initParticles();
 invalidateField();
 }
      if (k==='Mw' || k==='s' || k==='U0') { placeWells();
 invalidateField();
 }
      if (k==='N' || k==='aPx') initParticles();

      // observation network is purely visual, no extra recompute needed
      syncLabels();

    });

  }
  for (const r of document.getElementsByName('wmode')) { r.addEventListener('change', (e)=>{ state.wmode=e.target.value;
 placeWells();
 invalidateField();
 });
 }
  byId('showField').addEventListener('change', (e) => { state.showField = e.target.checked;
 invalidateField();
 });

  byId('toggle').addEventListener('click', ()=>{ state.running=!state.running;
 syncLabels();
 });

  byId('reseed').addEventListener('click', ()=>{ placeWells();
 initParticles();
 });


  function enforceRadiiConstraints() { const maxRin = Math.max(0.05, state.Rout - 0.02);
 if (state.Rin>maxRin) state.Rin=maxRin;
 byId('Rin').max=String(maxRin);
 byId('Rin').value=state.Rin;
 }

  // ----- Utils -----
  function randn(){ let u=0,v=0;
 while(u===0)u=Math.random();
 while(v===0)v=Math.random();
 return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
 }
  function reflectRadially(vx, vy, x, y) { const r=Math.hypot(x,y);
 if(!r) return {vx:-vx,vy:-vy};
 const nx=x/r, ny=y/r;
 const vdotn=vx*nx+vy*ny;
 return {vx: vx-2*vdotn*nx, vy: vy-2*vdotn*ny};
 }
  function randomPointInAnnulus(rin, rout){ const r2=rin*rin + Math.random()*(rout*rout - rin*rin);
 const r=Math.sqrt(r2), th=Math.random()*2*Math.PI;
 return {x:r*Math.cos(th), y:r*Math.sin(th)};
 }

  function getScale(){ const W=canvas.clientWidth||canvas.width;
 const H=canvas.clientHeight||canvas.height;
 return 0.45*Math.min(W,H)/state.Rout;
 }

  // ----- Wells -----
  let wells = [];
/**
   * placeWells() – Position potential wells either randomly in the annulus
   * or equidistantly on a ring of radius (Rin+Rout)/2.
*/
  function placeWells(){ wells.length=0;
 if(state.wmode==='ring'){ const Rc=0.5*(state.Rin+state.Rout);
 for(let i=0;
    i<state.Mw;
    i++){ 
        const th=2*Math.PI*i/state.Mw;
        wells.push({x:Rc*Math.cos(th), y:Rc*Math.sin(th)});
        } 
    } else { 
        for(let i=0;
        i<state.Mw;
        i++) wells.push(randomPointInAnnulus(state.Rin, state.Rout));
 } 
}

  // ----- Particles -----
  let particles = [];
 // {x,y,vx,vy,nx,ny}
  function initParticles(){ particles.length=0;
    const N=Math.round(state.N);
    const scale=getScale();
    const aWorld=Math.max(1e-6, state.aPx/scale);
    for(let i=0;
    i<N;
    i++)
    { 
        let placed=false;
        for(let t=0;
        t<500 && !placed;
        t++){ 
            const {x,y}=randomPointInAnnulus(state.Rin+aWorld, state.Rout-aWorld);
            if(particles.every(q=>Math.hypot(q.x-x,q.y-y)>=2*aWorld)){ const th=Math.random()*2*Math.PI;
                particles.push({x,y, vx:state.v0*Math.cos(th), vy:state.v0*Math.sin(th), nx:Math.cos(th), ny:Math.sin(th)});
                placed=true;
            } 
        } 
        if(!placed){ 
            const {x,y}=randomPointInAnnulus(state.Rin+aWorld, state.Rout-aWorld);
            const th=Math.random()*2*Math.PI;
            particles.push({x,y, vx:state.v0*Math.cos(th), vy:state.v0*Math.sin(th), nx:Math.cos(th), ny:Math.sin(th)});
        } 
    } 
}
/**
   * potentialForce(x,y) – Compute total force on a particle at (x,y).
   * Implements: F = -∇U, where U(x) = -U0 Σ exp(-||x-xi||^2 / (2s^2)).
*/
  function potentialForce(x,y){ 
    const invs2=1/(state.s*state.s);
 
    let fx=0, fy=0;
 
    for(const w of wells){ 
        const dx=x-w.x, dy=y-w.y;
        const r2=dx*dx+dy*dy; 
        const f=Math.exp(-0.5*r2*invs2);
        fx += -state.U0 * f * dx * invs2;
        fy += -state.U0 * f * dy * invs2;
    } 
    return {fx,fy};
 }

  // ----- Force colormap (smooth) -----
  let fieldCanvas = document.createElement('canvas');

  let fieldCtx = fieldCanvas.getContext('2d');

  let fieldDirty = true;
 // recompute on param/size change
  function invalidateField(){ fieldDirty = true;
 }

  function turbo(t){ // Google Turbo colormap
    t = Math.max(0, Math.min(1, t));

    const r = 0.13572138 + 4.61539260*t - 42.66032258*t*t + 132.13108234*t*t*t - 152.94239396*t*t*t*t + 59.28637943*t*t*t*t*t;

    const g = 0.09140261 + 2.19418839*t + 4.84296658*t*t - 14.18503333*t*t*t + 4.27729857*t*t*t*t + 2.82956604*t*t*t*t*t;

    const b = 0.10667330 + 12.64194608*t - 60.58204836*t*t + 110.36276771*t*t*t - 62.60975753*t*t*t*t + 13.15204352*t*t*t*t*t;

    return [Math.max(0,Math.min(255,Math.round(r*255))), Math.max(0,Math.min(255,Math.round(g*255))), Math.max(0,Math.min(255,Math.round(b*255)))];

  }

  // Gaussian blur helpers for smooth heatmap
  function blur1D(data, w, h, horiz=true) {
    const out = new Uint8ClampedArray(data.length);

    const k = [1,4,6,4,1], norm = 1/16;

    for (let y=0;
            y<h;
            y++) {
      for (let x=0;
        x<w;
        x++) {
        let r=0,g=0,b=0,a=0;

        for (let t=-2;
 t<=2;
 t++) {
          let xx = x + (horiz ? t : 0);

          let yy = y + (horiz ? 0 : t);

          if (xx<0) xx=0;
 if (xx>=w) xx=w-1;

          if (yy<0) yy=0;
 if (yy>=h) yy=h-1;

          const idx = (yy*w + xx)*4;

          const wgt = k[t+2];

          r += wgt*data[idx+0];

          g += wgt*data[idx+1];

          b += wgt*data[idx+2];

          a += wgt*data[idx+3];

        }
        const i2 = (y*w + x)*4;

        out[i2+0] = Math.round(r*norm);

        out[i2+1] = Math.round(g*norm);

        out[i2+2] = Math.round(b*norm);

        out[i2+3] = Math.round(a*norm);

      }
    }
    return out;

  }
  function gaussianBlurRGBA(imgData, w, h) { const pass1 = blur1D(imgData.data, w, h, true);
 const pass2 = blur1D(pass1, w, h, false);
 return new ImageData(pass2, w, h);
 }

// Simple dark-to-light colormap (blue → cyan → yellow → white)
function darkLightColormap(t){
  t = Math.max(0, Math.min(1, t));
  const r = Math.min(255, Math.round(255 * t));
  const g = Math.min(255, Math.round(255 * (0.5*t + 0.5*t*t)));
  const b = Math.min(255, Math.round(200 * (1 - t)));
  return [r,g,b];
}

/**
   * computeField() – Sample potential U(x,y) on a grid and map values to colors.
   * This visualizes the potential landscape (dark = high, light = low).
   */
function computeField(){
  const W = canvas.clientWidth|0, H = canvas.clientHeight|0;
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const size = Math.min(W,H);
  const grid = Math.min(1024, Math.max(256, Math.round(size * 0.9 * dpr * 1.6)));

  fieldCanvas.width = grid; fieldCanvas.height = grid;
  const img = fieldCtx.createImageData(grid, grid);
  const data = img.data;

  const cx = 0.5*grid, cy = 0.5*grid;
  const worldR = state.Rout;

  // compute potential at grid
  let minU = Infinity, maxU = -Infinity;
  const Us = new Float32Array(grid*grid);

  for (let j=0;j<grid;j++){
    for (let i=0;i<grid;i++){
      const x = (i - cx) / grid * 2 * worldR;
      const y = - (j - cy) / grid * 2 * worldR;
      const r = Math.hypot(x,y);
      let U = 0;
      if (r >= state.Rin && r <= state.Rout){
        for (const w of wells){
          const dx = x - w.x, dy = y - w.y;
          const r2 = dx*dx + dy*dy;
          U += -state.U0 * Math.exp(-0.5*r2/(state.s*state.s));
        }
      }
      Us[j*grid+i] = U;
      if (r >= state.Rin && r <= state.Rout){
        if (U < minU) minU = U;
        if (U > maxU) maxU = U;
      }
    }
  }

  // normalize potentials and map to colormap
  const range = maxU - minU || 1;
  for (let j=0;j<grid;j++){
    for (let i=0;i<grid;i++){
      const idx = j*grid+i;
      const U = Us[idx];
      const t = (U - minU)/range; // 0..1
      const [r,g,b] = darkLightColormap(t);
      const o = idx*4;
      data[o+0]=r; data[o+1]=g; data[o+2]=b;
      data[o+3]=(U===0?0:180); // alpha: transparent outside annulus
    }
  }

  fieldCtx.putImageData(img, 0, 0);
  fieldDirty = false;
}

  // ----- Collisions & Integration -----
  function resolveCollisions(){ 
    const scale=getScale();
 
    const a=Math.max(1e-6, state.aPx/scale);
 
    for(let i=0;
i<particles.length;
i++){ for(let j=i+1;
j<particles.length;
j++){ 
        const pi=particles[i], pj=particles[j];
 
        let dx=pj.x-pi.x, dy=pj.y-pi.y;
 
        let d=Math.hypot(dx,dy);
 
        const minD=2*a;
 if(d<minD && d>0){ 
            const overlap=minD-d;
 const nx=dx/d, ny=dy/d;
 
            pi.x -= 0.5*overlap*nx;
 
            pi.y -= 0.5*overlap*ny;
 
            pj.x += 0.5*overlap*nx;
 
            pj.y += 0.5*overlap*ny;
 
            const vi_n = pi.vx*nx + pi.vy*ny;
 
            const vj_n = pj.vx*nx + pj.vy*ny;
 
            pi.vx += (vj_n - vi_n)*nx;
            pi.vy += (vj_n - vi_n)*ny;
 
            pj.vx += (vi_n - vj_n)*nx;
            pj.vy += (vi_n - vj_n)*ny;
        } 
    } 
} 
}
/**
   * step() – Integrate one Euler–Maruyama timestep for each particle:
   *  dr = v dt
   *  dv = -∇U(x) dt + γ(v0 - |v|) v̂ dt + σ T v̂ dW
   * Includes specular reflection at annulus boundaries and particle–particle collision resolution.
   */
  function step(){ 
    const dt=state.dt, sq=Math.sqrt(dt);
 
    const scale=getScale();
 
    const a=Math.max(1e-6, state.aPx/scale);
 
    for(const p of particles){ 
        const vmag=Math.hypot(p.vx,p.vy);

        if(vmag!==0){ 
            p.nx=p.vx/vmag;
 
            p.ny=p.vy/vmag;
 } 
        const vhatx=p.nx, vhaty=p.ny;
 
        const {fx,fy}=potentialForce(p.x,p.y);
 
        const fdx = state.gamma * (state.v0 - vmag) * vhatx;
 
        const fdy = state.gamma * (state.v0 - vmag) * vhaty;
 
        const dW=randn()*sq;
 
        const nx=-vhaty, ny=vhatx;
 
        p.vx += (fx+fdx)*dt + state.sigma*nx*dW;
 
        p.vy += (fy+fdy)*dt + state.sigma*ny*dW;
 
        p.x += p.vx*dt;
        p.y += p.vy*dt;
 
        const r=Math.hypot(p.x,p.y);

            if(r>state.Rout-a){ 
            const rx=p.x/r, ry=p.y/r;
 
            p.x=rx*(state.Rout-a);
 
            p.y=ry*(state.Rout-a);
 
            const refl=reflectRadially(p.vx,p.vy,p.x,p.y);
 
            p.vx=refl.vx;
            p.vy=refl.vy;
        } 
        else if(r<state.Rin+a){ const rx=p.x/(r||1), ry=p.y/(r||1);

            p.x=rx*(state.Rin+a);
            p.y=ry*(state.Rin+a);
            const refl=reflectRadially(p.vx,p.vy,p.x,p.y);
            p.vx=refl.vx;
            p.vy=refl.vy;
        } 
    } 
        resolveCollisions();
 
    }

/**
   * draw() – Render the current simulation state:
   *  - Potential colormap (if enabled)
   *  - Annulus boundaries and wells
   *  - Observation network links between particles
   *  - Particles themselves
   */
  // ----- Drawing -----
  function draw(){ 
    const W=canvas.clientWidth, H=canvas.clientHeight;
 
    if(canvas.width!==W||canvas.height!==H){ canvas.width=W;
 
        canvas.height=H;
 
        invalidateField();
 
    }
    const cx=W*0.5, cy=H*0.5;

    const scale=getScale();


    ctx.clearRect(0,0,W,H);
 
    ctx.fillStyle='#ffffff';
 
    ctx.fillRect(0,0,W,H);


    // Force field colormap layer
    if (state.showField){ 
        if (fieldDirty) computeField();
 
        ctx.save();
 
        ctx.globalAlpha = 0.9;
 
        ctx.imageSmoothingEnabled = true;
 
        const size = Math.min(W,H)*0.90;
 
        const x = (W - size)/2, y = (H - size)/2;
 
        ctx.drawImage(fieldCanvas, x, y, size, size);
 
        ctx.restore();
 }

    // Annulus rings
    ctx.strokeStyle = '#4b5563';
    
    ctx.lineWidth = 2;
 
    ctx.beginPath();
 
    ctx.arc(cx, cy, state.Rout*scale, 0, 2*Math.PI);
 
    ctx.stroke();
    
    ctx.beginPath();
 
    ctx.arc(cx, cy, state.Rin*scale, 0, 2*Math.PI);
 
    ctx.stroke();

    // Wells (centers)
    for (const w of wells){ 
        const X=cx + w.x*scale, Y=cy - w.y*scale;
 
        ctx.beginPath();
        ctx.arc(X, Y, 6, 0, 2*Math.PI);
        ctx.fillStyle='rgba(0,0,0,1)';
        ctx.fill();
 }

    // Observation network: links between particles within obsR
    const linkColor = getComputedStyle(document.documentElement).getPropertyValue('--link').trim() || '#0ea5e9';

    ctx.save();
    ctx.lineWidth = state.linkW;
    ctx.globalAlpha = state.linkA;
    ctx.strokeStyle = linkColor;

    for(let i=0;
        i<particles.length;
        i++)
        {
            const pi = particles[i];
            for(let j=i+1;
                j<particles.length;
                j++)
                {
                    const pj = particles[j];
                    const dx = pj.x - pi.x, dy = pj.y - pi.y;
                    const d = Math.hypot(dx,dy);
                    if (d <= state.obsR){
                        const Xi = cx + pi.x*scale, Yi = cy - pi.y*scale;

                        const Xj = cx + pj.x*scale, Yj = cy - pj.y*scale;

                        ctx.beginPath();
                        ctx.moveTo(Xi, Yi);
                        ctx.lineTo(Xj, Yj);
                        ctx.stroke();

        }
      }
    }
    ctx.restore();

    // Particles
    const aPx = state.aPx;
 
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--particle');
 
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--particle-edge');
 
    ctx.lineWidth = 1;
 
    for(const p of particles){ 
        const X=cx + p.x*scale, Y=cy - p.y*scale;
 
        ctx.beginPath();
 
        ctx.arc(X, Y, aPx, 0, 2*Math.PI);
 
        ctx.fill();
        ctx.stroke();
        }
         }
     
        function loop(){ if(state.running) step();
        draw();
        requestAnimationFrame(loop);
        }
    
         function initUIValuesFromState(){ for(const elId in sliders) byId(elId).value = state[sliders[elId]];
        syncLabels();
        enforceRadiiConstraints();
        }
    
         // ----- Init -----
         function initAll(){ placeWells();
        initUIValuesFromState();
        initParticles();
        invalidateField();
        loop();
        }
         initAll();
    
}       )();

</script>
</body>
</html>
